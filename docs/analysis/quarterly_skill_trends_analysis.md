# 분기별 스킬 트렌드 분석 문제 및 해결 방안

## 1. 핵심 원인 분석

### 현재 코드의 실행 순서

```222:233:app/db/crud/db_skill_insights.py
    # 3단계: 통합된 스킬 리스트로 최종 결과 필터링
    # 전체 기간 합계 기준으로 정렬하여 최종 상위 N개 선택
    if top_skills_set:
        skill_totals = all_df[all_df['skill_name'].isin(top_skills_set)].groupby('skill_name')['count'].sum().sort_values(ascending=False)
        final_top_skills = skill_totals.head(top_n).index.tolist()
        
        # 최종 스킬 리스트로 필터링
        filtered_df = all_df[all_df['skill_name'].isin(final_top_skills)]
    else:
        filtered_df = all_df
    
    return filtered_df
```

```119:122:app/services/dashboard/skill_insights.py
        # 스킬 목록 추출 (전체 기간 두 연도 합계 기준 정렬)
        # 전체 기간의 합계를 기준으로 상위 스킬 동적 선택
        skill_totals = df.groupby('skill_name')['count'].sum().sort_values(ascending=False)
        skills = skill_totals.head(top_n).index.tolist()
```

### 문제 발생 메커니즘

1. **1단계**: 모든 분기의 데이터를 스킬 필터 없이 조회 ✅ (정상)
2. **2단계**: 각 분기별로 상위 N개 스킬을 선택하고 통합 ✅ (정상)
3. **3단계 (문제)**: 전체 기간 합계 기준으로 정렬하여 최종 상위 N개 선택 ❌
   - 예: 2024 Q1-Q4 + 2025 Q1-Q4의 모든 카운트를 합산
   - 2025 Q4에 Python이 76개, 2024 전체에 Python이 10개라면
   - 전체 합계 86개로 Python이 상위에 포함됨
   - 하지만 2024 Q1-Q4에서는 Python이 각각 0~3개 정도만 존재
4. **서비스 레이어에서 재선택**: `_get_single_year_trends`에서 다시 전체 합계 기준으로 상위 스킬 선택 ❌
   - 이중 필터링으로 문제가 더 심화됨

### 왜 이런 문제가 발생하는가?

- **시간 가중치 불균형**: 최근 분기(2025 Q4)의 데이터가 전체 합계에 큰 영향을 미침
- **스킬 트렌드 변화**: 각 분기마다 인기 있는 스킬이 다를 수 있음
  - 2024 Q1: React, TypeScript가 인기
  - 2025 Q4: Python, Kubernetes가 인기
- **고정 스킬 리스트의 한계**: 전체 기간 합계로 선택된 스킬 리스트는 과거 분기에서 의미 없는 0값을 생성

## 2. 올바른 접근 방법

### 각 분기별 독립적 스킬 추출의 필요성

각 분기는 독립적인 시장 환경을 반영합니다:
- **계절적 요인**: 특정 분기에만 집중 채용 (예: 신입사원 채용 시즌)
- **기술 트렌드 변화**: 새로운 기술의 급속한 도입
- **산업 동향**: 특정 산업의 성장/축소

### 권장 접근 방법

1. **각 분기별로 상위 N개 스킬 추출**
2. **모든 분기의 스킬을 통합하여 유니크한 스킬 세트 생성**
3. **통합된 스킬 세트를 모든 분기에 적용** (없는 분기는 0으로 표시)

이렇게 하면:
- 각 분기의 실제 인기 스킬이 포함됨
- 과거 분기에서도 의미 있는 데이터가 표시됨
- 스킬 리스트가 동적으로 구성되어 트렌드 변화를 반영

## 3. 예상되는 트레이드오프

### 문제점 1: 스킬 리스트가 분기마다 다를 수 있음

**영향**:
- 프론트엔드에서 고정된 스킬 리스트를 기대하는 경우 문제 발생
- 차트/그래프에서 스킬이 갑자기 나타나거나 사라질 수 있음

**해결책**:
- 통합 스킬 세트를 사용하여 모든 분기에 동일한 스킬 리스트 제공
- 각 분기별로 상위 N개를 추출하되, 최종적으로는 통합된 리스트 사용

### 문제점 2: 프론트엔드에서 동적 스킬 세트 처리 필요

**영향**:
- 스킬 개수가 `top_n`보다 많을 수 있음 (예: 8개 분기 × 10개 = 최대 80개)
- 프론트엔드에서 스킬 리스트를 동적으로 렌더링해야 함

**해결책**:
- API 응답에 스킬 리스트를 명시적으로 포함
- 프론트엔드에서 `skills` 배열을 기반으로 동적 렌더링
- 스킬 개수 제한 (예: 최대 30개)

### 문제점 3: 특정 스킬의 장기 시계열 추적이 어려움

**영향**:
- 특정 스킬(예: "Python")이 모든 분기에 포함되지 않을 수 있음
- 장기 트렌드를 분석하기 어려움

**해결책**:
- 통합 스킬 세트를 사용하면 모든 분기에 동일한 스킬이 포함됨
- 없는 분기는 0으로 표시되어 시계열 추적 가능

## 4. 대안 솔루션

### 솔루션 A: 통합 스킬 세트 방식 (권장)

**접근 방법**:
1. 각 분기별로 상위 N개 스킬 추출
2. 모든 분기의 스킬을 통합하여 유니크한 세트 생성
3. 통합된 스킬 세트를 모든 분기에 적용

**장점**:
- 각 분기의 실제 인기 스킬 포함
- 고정된 스킬 리스트로 프론트엔드 처리 용이
- 장기 시계열 추적 가능

**단점**:
- 스킬 개수가 `top_n`보다 많을 수 있음 (최대 분기 수 × top_n)

**구현 예시**:
```python
# 각 분기별 상위 N개 추출
quarterly_top_skills = {}
for year in [year, comparison_year]:
    for quarter in [1, 2, 3, 4]:
        quarter_df = all_df[(all_df['year'] == year) & (all_df['quarter'] == quarter)]
        if not quarter_df.empty:
            top_skills = quarter_df.nlargest(top_n, 'count')['skill_name'].tolist()
            quarterly_top_skills[(year, quarter)] = top_skills

# 통합 스킬 세트 생성
all_top_skills = set()
for skills in quarterly_top_skills.values():
    all_top_skills.update(skills)

# 최종 스킬 리스트 (선택적으로 상위 M개로 제한)
final_skills = list(all_top_skills)[:max_skills]  # 예: 최대 30개
```

### 솔루션 B: 가중치 기반 선택

**접근 방법**:
1. 각 분기의 데이터에 시간 가중치 적용 (최근 분기일수록 낮은 가중치)
2. 가중치가 적용된 합계로 상위 스킬 선택

**장점**:
- 과거 분기의 중요성을 높임
- 고정된 스킬 리스트 유지

**단점**:
- 가중치 조정이 복잡함
- 여전히 최근 분기 편향 가능성

### 솔루션 C: 분기별 독립 스킬 리스트 (비권장)

**접근 방법**:
- 각 분기마다 완전히 독립적인 상위 N개 스킬 반환

**단점**:
- 프론트엔드 처리 복잡도 증가
- 시계열 비교 불가능
- 스킬 리스트가 분기마다 완전히 다름

## 5. 권장 구현 방안

**최종 권장**: 솔루션 A (통합 스킬 세트 방식)

**이유**:
1. 각 분기의 실제 트렌드를 반영
2. 프론트엔드에서 고정된 스킬 리스트로 처리 가능
3. 장기 시계열 추적 가능
4. 구현이 상대적으로 단순

**추가 고려사항**:
- 스킬 개수 제한: 통합 스킬 세트가 너무 많아지지 않도록 최대 개수 설정 (예: 30개)
- 정렬 기준: 통합 스킬 세트를 전체 기간 합계로 정렬하여 상위 M개 선택
- 성능: 분기 수가 많을 경우 최적화 필요

